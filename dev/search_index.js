var documenterSearchIndex = {"docs":
[{"location":"MaterialProperties/#Yagami.MaterialProperties.refractive_index!-Union{Tuple{A}, Tuple{G}, Tuple{G, Vararg{A, 6}}} where {G<:AirModel, A}","page":"MaterialProperties","title":"Yagami.MaterialProperties.refractive_index!","text":"refractive_index!(\n    model,\n    n,\n    temperature,\n    pressure,\n    wavelength,\n    humidity,\n    CO2ppm\n)\n\n\nReturns the refractive index of air at a given wavelength and temperature, pressure, and humidity. The refractive index is calculated using the specified air model and parameters.\n\nArguments\n\nmodel::G: The air model to use for the calculation, which must be a subtype of AirModel.\nn::A: An array to store the calculated refractive index values.\ntemperature::A: An array of temperatures in Kelvin.\npressure::A: An array of pressures in Pascals.\nwavelength::A: An array of wavelengths in micrometers.\nhumidity::A: An array of relative humidity values as percentages (0-100).\nCO2ppm::A: An array of CO2 concentrations in parts per million\n\n\n\n\n\n","category":"method"},{"location":"MaterialProperties/#Yagami.MaterialProperties.refractive_index-Union{Tuple{T}, Tuple{G}, Tuple{G, Vararg{T, 5}}} where {G<:AirModel, T<:AbstractFloat}","page":"MaterialProperties","title":"Yagami.MaterialProperties.refractive_index","text":"refractive_index(\n    model,\n    temperature,\n    pressure,\n    wavelength,\n    humidity,\n    CO2ppm\n)\n\n\nReturns the refractive index of air at a given wavelength and temperature, pressure, and humidity. The refractive index is calculated using the specified air model and parameters.\n\nArguments\n\nmodel::G: The air model to use for the calculation, which must be a subtype of AirModel.\ntemperature::Real: The temperature in Kelvin.\npressure::Real: The pressure in Pascals.\nwavelength::Real: The wavelength in micrometers.\nhumidity::Real: The relative humidity as a percentage (0-100).\nCO2ppm::Real: The CO2 concentration in parts per million (ppm\n\nReturns\n\nThe refractive index of air at the specified wavelength and conditions.\n\n\n\n\n\n","category":"method"},{"location":"YagamiCore/#Yagami.YagamiCore.Zbrent-Union{Tuple{T}, Tuple{F}, Tuple{Type{<:T}, F}, Tuple{Type{<:T}, F, Int64}, Tuple{Type{<:T}, F, Int64, T}} where {F, T<:AbstractFloat}","page":"YagamiCore","title":"Yagami.YagamiCore.Zbrent","text":"Zbrent{F,T<:AbstractFloat}(f::F, a::T, fx::T, x::T, b::T, tol::T, itermax::Int=100, __iter::Int=0)\n\nCreate a new instance of Zbrent for finding the minimum of a function f. The parameters are:\n\nf: the function to find the minimum of.\nitermax: the maximum number of iterations to perform.\ntol: the tolerance for convergence. (note it is not the absolute tolerance)\n\n\n\n\n\n","category":"method"},{"location":"YagamiCore/#Yagami.YagamiCore.Zbrent-Union{Tuple{}, Tuple{Type{<:T}}, Tuple{T}, Tuple{F}} where {F, T<:AbstractFloat}","page":"YagamiCore","title":"Yagami.YagamiCore.Zbrent","text":"`Zbrent([type=Float64]; f::F, itermax::Int=100, tol::T=T(TOL)) where {F,T<:AbstractFloat}`\n\nCreate a new instance of Zbrent for finding the minimum of a function f. The parameters are:\n\ntype: the type of the floating point numbers to use (default is Float64).\nf: the function to find the minimum of.\nitermax: the maximum number of iterations to perform.\ntol: the tolerance for convergence (default is T(TOL)).\n\n\n\n\n\n","category":"method"},{"location":"YagamiCore/#Yagami.YagamiCore.bracketmin-Union{Tuple{Z}, Tuple{T}, Tuple{F}, Tuple{Z, T}, Tuple{Z, T, T}} where {F, T<:AbstractFloat, Z<:Yagami.YagamiCore.Zbrent{F, T}}","page":"YagamiCore","title":"Yagami.YagamiCore.bracketmin","text":"bracketmin(z::Zbrent{F,T},min_val=0.0,multiplier=2.0) where {F,T<:AbstractFloat} Bracket the function z.f to find a minimum. This function sets the initial bounds for the Brent's method. It uses the golden section search to find a point where the function value is lower than the initial bounds.\n\n\n\n\n\n","category":"method"},{"location":"YagamiCore/#Yagami.YagamiCore.file_to_array-Union{Tuple{String}, Tuple{S}, Tuple{T}, Tuple{String, Int64}, Tuple{String, Int64, Type{T}}, Tuple{String, Int64, Type{T}, S}} where {T, S<:AbstractString}","page":"YagamiCore","title":"Yagami.YagamiCore.file_to_array","text":"`file_to_array(filename,header,type=Float64,spacer=\" \")`\n\nRead a file and convert its contents into a vector of type type. The file is expected to have a header of header lines, which will be skipped. The contents of the file are split by the specified spacer, and each element is parsed to the specified type.\n\nArguments:\n\nfilename::String: The path to the file to be read.\nheader::Int=0: The number of header lines to skip in the file (default is 0).\ntype::Type{T}=Float64: The type to which the elements of the file will be parsed (default is Float64).\nspacer::S=\" \": The string used to split the contents of the file (default is a single space).\n\nReturns:\n\nVector{T}: An array of type T containing the parsed elements from the file.\n\nExample:\n\njulia> file_to_array(\"data.txt\", header=1, type=Float64, spacer=\",\")\n[1.0, 2.0, 3.0, 4.0]\n\n\n\n\n\n","category":"method"},{"location":"YagamiCore/#Yagami.YagamiCore.findraymin-Union{Tuple{Z}, Tuple{T}, Tuple{F}} where {F, T<:AbstractFloat, Z<:Yagami.YagamiCore.Zbrent{F, T}}","page":"YagamiCore","title":"Yagami.YagamiCore.findraymin","text":"findraymin(zb::Zbrent{F,T}) where {F,T<:AbstractFloat}\n\nFind the minimum of the function zb.f using the Brent's method. The function zb.f must be defined such that it returns a value for a given input x. The method uses a combination of bisection, secant, and inverse quadratic interpolation to find the minimum.\n\n\n\n\n\n","category":"method"},{"location":"YagamiCore/#Yagami.YagamiCore.infologger-Tuple{String}","page":"YagamiCore","title":"Yagami.YagamiCore.infologger","text":"infologger(filename::String)\n\nCreate a logger that writes log messages to a file. This logger uses the FormatLogger to format messages and write them to the specified file.\n\n\n\n\n\n","category":"method"},{"location":"RayTracing/#Yagami.RayTracing.AtmInterpolate","page":"RayTracing","title":"Yagami.RayTracing.AtmInterpolate","text":"AtmInteoplate{N,M,T}\n\nA structure representing an atmospheric interpolation object for ray tracing.\n\nAtmInterpolate(knots_θ, knots_h, parameters; logh=false)\n\nCreate an atmospheric interpolation object for ray tracing. The interpolation is defined by the knots of height and angle, and the parameters matrix.\n\nArguments\n\nknots_θ::AbstractVector{T}: A vector of angles in degrees, where T is a subtype of AbstractFloat.\nknots_h::AbstractVector{T}: A vector of heights in kilometers, where T is a subtype of AbstractFloat.\nparameters::AbstractMatrix{T}: A matrix of parameters for the interpolation, where T is a subtype of AbstractFloat.\nlogh::Bool: If true, use logarithmic interpolation for height. Default is false.\n\nReturns\n\nAn AtmInterpolate object with the specified knots and parameters.\n\n\n\n\n\n","category":"type"},{"location":"RayTracing/#Yagami.RayTracing.AtmosphereSetting","page":"RayTracing","title":"Yagami.RayTracing.AtmosphereSetting","text":"AtmosphereSetting(knots_θ, knots_h, temperature, pressure, humidity=0.0, co2ppm=0.0, wavelength=10.0)\n\nCreate an atmosphere setting interpolation object for ray tracing.\n\nArguments\n\nknots_θ::AbstractVector{T}: A vector of angles in degrees, where T is a subtype of AbstractFloat.\nknots_h::AbstractVector{T}: A vector of heights in kilometers, where T is a subtype of AbstractFloat.\ntemperature::AbstractMatrix{T}: A matrix of temperature values, where each row corresponds to a level and each column corresponds to a radius.\npressure::AbstractMatrix{T}: A matrix of pressure values, where each row corresponds to a level and each column corresponds to a radius.\nhumidity::AbstractFloat (optional): A scalar or matrix of humidity values, default is 0.0. If a scalar is provided, it is broadcasted to match the size of the temperature matrix.\nco2ppm::AbstractFloat (optional): A scalar or matrix of CO2 concentration values in parts per million, default is 0.0. If a scalar is provided, it is broadcasted to match the size of the temperature matrix.\nwavelength::AbstractFloat (optional): A scalar or matrix of wavelength values, default is 10.0. If a scalar is provided, it is broadcasted to match the size of the temperature matrix.\n\nReturns\n\nAn AtmosphereSetting object containing interpolated atmospheric properties for ray tracing.\n\n\n\n\n\n","category":"type"},{"location":"RayTracing/#Yagami.RayTracing.RayTracingProblem","page":"RayTracing","title":"Yagami.RayTracing.RayTracingProblem","text":"Data structure for the ray tracing problem. This struct holds all the necessary data for performing ray tracing calculations, including the atmosphere, refractive index, and satellite scan information.\n\n\n\n\n\n","category":"type"},{"location":"RayTracing/#Yagami.RayTracing.RayTracingProblem-Union{Tuple{String}, Tuple{ADF}, Tuple{EA}, Tuple{AM}, Tuple{MT}, Tuple{String, ADF}} where {MT<:MeanType, AM<:AirModel, EA<:EarthApproximation, ADF<:Yagami.RayTracing.AvailableDataFormat}","page":"RayTracing","title":"Yagami.RayTracing.RayTracingProblem","text":"RayTracingProblem(fileorfolder; ...)\nRayTracingProblem(\n    fileorfolder,\n    dataformat;\n    meantype,\n    model,\n    earthmodel,\n    logger\n)\n\n\nCreate a RayTracingProblem from an available data format. This function is a factory method that dispatch  a RayTracingProblem based on the specified data format.\n\nArguments:\n\nfileorfolder::String: The path to the file or folder containing the ray tracing data.\ndataformat::ADF: The data format of the file or folder, which can be NCFormat or MipasFormat. (default is NCFormat).\nmeantype::MT=GeometricMean(): The mean type to be used for the refractive index calculation (default is GeometricMean).\nmodel::AM=Ciddor(): The air model to be used for the refractive index calculation (default is Ciddor).\nearthmodel::EA=Fukushima(): The earth approximation model to be used (default is Fukushima).\nlogger=nothing: An optional logger to log information during the problem creation (default is NullLogger).\n\nReturns:\n\nRayTracingProblem: An instance of RayTracingProblem containing the data read from the file or folder and the calculated refractive index and atmosphere.\n\n\n\n\n\n","category":"method"},{"location":"RayTracing/#Yagami.RayTracing.SimpleResult-Union{Tuple{}, Tuple{T}, Tuple{T, T}, Tuple{T, T, T}, NTuple{4, T}, NTuple{5, T}, NTuple{6, T}, NTuple{7, T}, Tuple{T, T, T, T, T, T, T, Int64}, Tuple{T, T, T, T, T, T, T, Int64, Int64}, Tuple{T, T, T, T, T, T, T, Int64, Int64, Bool}} where T<:AbstractFloat","page":"RayTracing","title":"Yagami.RayTracing.SimpleResult","text":"SimpleResult()\nSimpleResult(pointx)\nSimpleResult(pointx, pointy)\nSimpleResult(pointx, pointy, directionx)\nSimpleResult(pointx, pointy, directionx, directiony)\nSimpleResult(\n    pointx,\n    pointy,\n    directionx,\n    directiony,\n    altitude\n)\nSimpleResult(\n    pointx,\n    pointy,\n    directionx,\n    directiony,\n    altitude,\n    azimuth\n)\nSimpleResult(\n    pointx,\n    pointy,\n    directionx,\n    directiony,\n    altitude,\n    azimuth,\n    length\n)\nSimpleResult(\n    pointx,\n    pointy,\n    directionx,\n    directiony,\n    altitude,\n    azimuth,\n    length,\n    i\n)\nSimpleResult(\n    pointx,\n    pointy,\n    directionx,\n    directiony,\n    altitude,\n    azimuth,\n    length,\n    i,\n    j\n)\nSimpleResult(\n    pointx,\n    pointy,\n    directionx,\n    directiony,\n    altitude,\n    azimuth,\n    length,\n    i,\n    j,\n    descending\n)\n\n\nCreate a SimpleResult with default values for the fields. SimpleResult is a data structure used to store the results of ray tracing calculations and it is a sybtype of AbstractResult.\n\nArguments\n\npointx::T=MAJORAXIS(): X-coordinate of the point, default is the major axis.\npointy::T=MINORAXIS(): Y-coordinate of the point, default is the minor axis.\ndirectionx::T=0.0: X-component of the direction vector, default is 0.0.\ndirectiony::T=-1.0: Y-component of the direction vector, default is -1.0.\naltitude::T=zero(T): Altitude, default is 0.\nazimuth::T=zero(T): Azimuth, default is 0.\nlength::T=zero(T): Length, default is 0.\ni::Int=0: Index i, default is 0.\nj::Int=0: Index j, default is 0.\ndescending::Bool=true: Whether the ray is descending, default is true.\nReturns\nA SimpleResult object with the specified or default values.\n\n\n\n\n\n","category":"method"},{"location":"RayTracing/#Yagami.RayTracing.GeofitRayTracingProblem-Union{Tuple{String}, Tuple{EA}, Tuple{AM}, Tuple{MT}} where {MT<:MeanType, AM<:AirModel, EA<:EarthApproximation}","page":"RayTracing","title":"Yagami.RayTracing.GeofitRayTracingProblem","text":"GeofitRayTracingProblem(\n    folder;\n    meantype,\n    model,\n    earthmodel,\n    logger,\n    humidity,\n    co2ppm\n)\n\n\nCreate a RayTracingProblem from a Mipas folder. This struct represents a ray tracing problem with all the necessary data to perform ray tracing calculations, including the atmosphere, refractive index, and satellite scan information.\n\nArguments:\n\nfilename::String: The path to the Cairt file containing the ray tracing data.\n\nKey Arguments:\n\nmeantype::MT=GeometricMean(): The mean type to be used for the refractive index calculation (default is GeometricMean).\nmodel::AM=Ciddor(): The air model to be used for the refractive index calculation (default is Ciddor).\nearthmodel::EA=Fukushima(): The earth approximation model to be used (default is Fukushima).\nlogger=nothing: An optional logger to log information during the problem creation (default is NullLogger).\n\nReturns:\n\nRayTracingProblem: An instance of RayTracingProblem containing the data read from the Cairt file and the calculated refractive index and atmosphere.\n\n\n\n\n\n","category":"method"},{"location":"RayTracing/#Yagami.RayTracing.NCRayTracingProblem-Union{Tuple{String}, Tuple{EA}, Tuple{AM}, Tuple{MT}} where {MT<:MeanType, AM<:AirModel, EA<:EarthApproximation}","page":"RayTracing","title":"Yagami.RayTracing.NCRayTracingProblem","text":"NCRayTracingProblem(\n    filename;\n    meantype,\n    model,\n    earthmodel,\n    logger,\n    humidity,\n    co2ppm\n)\n\n\nCreate a RayTracingProblem from a Cairt file. This struct represents a ray tracing problem with all the necessary data to perform ray tracing calculations, including the atmosphere, refractive index, and satellite scan information.\n\nArguments:\n\n::Cairt: A type representing the Cairt file format, which is used to read the ray tracing data.\nfilename::String: The path to the Cairt file containing the ray tracing data.\n\nKey Arguments:\n\nmeantype::MT=GeometricMean(): The mean type to be used for the refractive index calculation (default is GeometricMean).\nmodel::AM=Ciddor(): The air model to be used for the refractive index calculation (default is Ciddor).\nearthmodel::EA=Fukushima(): The earth approximation model to be used (default is Fukushima).\nlogger=nothing: An optional logger to log information during the problem creation (default is NullLogger).\n\nReturns:\n\nRayTracingProblem: An instance of RayTracingProblem containing the data read from the Cairt file and the calculated refractive index and atmosphere.\n\n\n\n\n\n","category":"method"},{"location":"RayTracing/#Yagami.RayTracing.__setdescending!-Union{Tuple{DistanceFunc}, Tuple{Bool}, Tuple{DistanceFunc, Bool}} where Bool","page":"RayTracing","title":"Yagami.RayTracing.__setdescending!","text":"__setdescending!(df::DistanceFunc, value::Bool=true) Set the :descending field of the DistanceFunc.\n\n\n\n\n\n","category":"method"},{"location":"RayTracing/#Yagami.RayTracing.__setdirectionx!-Union{Tuple{DistanceFunc}, Tuple{T}, Tuple{DistanceFunc, T}} where T","page":"RayTracing","title":"Yagami.RayTracing.__setdirectionx!","text":"__setdirectionx!(df::DistanceFunc, value::T=0.0) Set the :directionx field of the DistanceFunc.\n\n\n\n\n\n","category":"method"},{"location":"RayTracing/#Yagami.RayTracing.__setdirectiony!-Union{Tuple{DistanceFunc}, Tuple{T}, Tuple{DistanceFunc, T}} where T","page":"RayTracing","title":"Yagami.RayTracing.__setdirectiony!","text":"__setdirectiony!(df::DistanceFunc, value::T=1.0) Set the :directiony field of the DistanceFunc.\n\n\n\n\n\n","category":"method"},{"location":"RayTracing/#Yagami.RayTracing.__sethmax!-Union{Tuple{DistanceFunc}, Tuple{T}, Tuple{DistanceFunc, T}} where T","page":"RayTracing","title":"Yagami.RayTracing.__sethmax!","text":"__sethmax!(df::DistanceFunc, value::T=120.0) Set the :hmax field of the DistanceFunc.\n\n\n\n\n\n","category":"method"},{"location":"RayTracing/#Yagami.RayTracing.__sethmin!-Union{Tuple{DistanceFunc}, Tuple{T}, Tuple{DistanceFunc, T}} where T","page":"RayTracing","title":"Yagami.RayTracing.__sethmin!","text":"__sethmin!(df::DistanceFunc, value::T=0.0) Set the :hmin field of the DistanceFunc.\n\n\n\n\n\n","category":"method"},{"location":"RayTracing/#Yagami.RayTracing.__seti!-Union{Tuple{DistanceFunc}, Tuple{Int}, Tuple{DistanceFunc, Int}} where Int","page":"RayTracing","title":"Yagami.RayTracing.__seti!","text":"__seti!(df::DistanceFunc, value::Int=0) Set the :i field of the DistanceFunc.\n\n\n\n\n\n","category":"method"},{"location":"RayTracing/#Yagami.RayTracing.__setislevel!-Union{Tuple{DistanceFunc}, Tuple{Bool}, Tuple{DistanceFunc, Bool}} where Bool","page":"RayTracing","title":"Yagami.RayTracing.__setislevel!","text":"__setislevel!(df::DistanceFunc, value::Bool=true) Set the :islevel field of the DistanceFunc.\n\n\n\n\n\n","category":"method"},{"location":"RayTracing/#Yagami.RayTracing.__setj!-Union{Tuple{DistanceFunc}, Tuple{Int}, Tuple{DistanceFunc, Int}} where Int","page":"RayTracing","title":"Yagami.RayTracing.__setj!","text":"__setj!(df::DistanceFunc, value::Int=0) Set the :j field of the DistanceFunc.\n\n\n\n\n\n","category":"method"},{"location":"RayTracing/#Yagami.RayTracing.__setn!-Union{Tuple{DistanceFunc}, Tuple{T}, Tuple{DistanceFunc, T}} where T","page":"RayTracing","title":"Yagami.RayTracing.__setn!","text":"__setn!(df::DistanceFunc, value::T=1.0) Set the :n field of the DistanceFunc.\n\n\n\n\n\n","category":"method"},{"location":"RayTracing/#Yagami.RayTracing.__setpointx!-Union{Tuple{DistanceFunc}, Tuple{T}, Tuple{DistanceFunc, T}} where T","page":"RayTracing","title":"Yagami.RayTracing.__setpointx!","text":"__setpointx!(df::DistanceFunc, value::T=1.0e-5) Set the :pointx field of the DistanceFunc.\n\n\n\n\n\n","category":"method"},{"location":"RayTracing/#Yagami.RayTracing.__setpointy!-Union{Tuple{DistanceFunc}, Tuple{T}, Tuple{DistanceFunc, T}} where T","page":"RayTracing","title":"Yagami.RayTracing.__setpointy!","text":"__setpointy!(df::DistanceFunc, value::T=1.0e-5) Set the :pointy field of the DistanceFunc.\n\n\n\n\n\n","category":"method"},{"location":"RayTracing/#Yagami.RayTracing.__setθmax!-Union{Tuple{DistanceFunc}, Tuple{T}, Tuple{DistanceFunc, T}} where T","page":"RayTracing","title":"Yagami.RayTracing.__setθmax!","text":"__setθmax!(df::DistanceFunc, value::T=Inf) Set the :θmax field of the DistanceFunc.\n\n\n\n\n\n","category":"method"},{"location":"RayTracing/#Yagami.RayTracing.__setθmin!-Union{Tuple{DistanceFunc}, Tuple{T}, Tuple{DistanceFunc, T}} where T","page":"RayTracing","title":"Yagami.RayTracing.__setθmin!","text":"__setθmin!(df::DistanceFunc, value::T=-Inf) Set the :θmin field of the DistanceFunc.\n\n\n\n\n\n","category":"method"},{"location":"RayTracing/#Yagami.RayTracing.create_atmosphere-Union{Tuple{}, Tuple{T}} where T<:AbstractFloat","page":"RayTracing","title":"Yagami.RayTracing.create_atmosphere","text":"create_atmosphere(; θᵢ, hᵢ, temperatureᵢ, pressureᵢ, humidity=0.0, co2ppm=0.0, wavelength=10.0, knots_θ=create_hlevelset(T;), knots_h=create_radii(T;))\n\nCreate an atmosphere setting for ray tracing. This function generates an AtmosphereSetting object based on the provided parameters, which include angles, heights, temperature, pressure, humidity, CO2 concentration, and wavelength.\n\nKey Arguments\n\nθᵢ::AbstractVector{T}: A vector of angles in degrees, where T is a subtype of AbstractFloat.\nhᵢ::AbstractVector{T}: A vector of heights in kilometers, where T is a subtype of AbstractFloat.\ntemperatureᵢ::AbstractMatrix{T}: A matrix of temperature values, where each row corresponds to a level and each column corresponds to a radius.\npressureᵢ::AbstractMatrix{T}: A matrix of pressure values, where each row corresponds to a level and each column corresponds to a radius.\nhumidity=0.0: A scalar or matrix of humidity values, default is 0.0. If a scalar is provided, it is broadcasted to match the size of the temperature matrix.\nco2ppm=0.0: A scalar or matrix of CO2 concentration values in parts per million, default is 0.0. If a scalar is provided, it is broadcasted to match the size of the temperature matrix.\nwavelength=10.0: A scalar or matrix of wavelength values, default is 10.0. If a scalar is provided, it is broadcasted to match the size of the temperature matrix.\nknots_θ::AbstractVector{T}=create_hlevelset(T;): A vector of angles in degrees for the knots, default is created using create_hlevelset.\nknots_h::AbstractVector{T}=create_radii(T;): A vector of heights in kilometers for the knots, default is created using create_radii.\n\nReturns\n\nAn AtmosphereSetting object containing interpolated atmospheric properties for ray tracing.\n\n\n\n\n\n","category":"method"},{"location":"RayTracing/#Yagami.RayTracing.create_hlevelset-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T<:AbstractFloat","page":"RayTracing","title":"Yagami.RayTracing.create_hlevelset","text":"create_hlevelset(; ...)\ncreate_hlevelset(; hmin, hmax, levels, logscale)\n\n\nCreate a set of levels for the raytracing method. The levels are evenly spaced in the range [hmin, hmax] if logscale=false, or logarithmically spaced if logscale=true.\n\nNote\n\nThe levels are sorted in descending order, meaning the first element is the maximum level and the last element is the minimum level. This is the format required by the reay tracing algorithm.\n\nArguments\n\nT::Type{<:AbstractFloat}: The type of the levels, default is Float64.\nhmin::T: The minimum value of the levels, default is 0.0.\nhmax::T: The maximum value of the levels, default is 120.0.\nlevels::Int: The number of levels to create, must be a positive integer, default is 100.\nlogscale::Bool: If true, the levels are logarithmically spaced; if false, they are linearly spaced. Default is true.\n\nReturns\n\nA vector of levels of type T, either logarithmically or linearly spaced between hmin and hmax.\n\n\n\n\n\n","category":"method"},{"location":"RayTracing/#Yagami.RayTracing.create_radii-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T<:AbstractFloat","page":"RayTracing","title":"Yagami.RayTracing.create_radii","text":"create_radii(; ...)\ncreate_radii(; θmin, θmax, radii)\n\n\nCreate a set of radii for the raytracing method. The radii are evenly spaced in the range [θmin, θmax].\n\nNote\n\nThe radii are sorted in ascending order, meaning the first element is the minimum radius and the last element is the maximum radius.\n\nArguments\n\nT::Type{<:AbstractFloat}: The type of the radii, default is Float64.\nθmin::AbstractFloat: The minimum angle in degrees, default is 0.0.\nθmax::AbstractFloat: The maximum angle in degrees, default is 359.0.\nradii::Int: The number of radii to create, must be a positive integer, default is 360.\n\nReturns\n\nA vector of radii of type T, evenly spaced between θmin and θmax.\n\n\n\n\n\n","category":"method"},{"location":"RayTracing/#Yagami.RayTracing.extrapolateco2ppm-Union{Tuple{RTP}, Tuple{T}, Tuple{RTP, T, T}} where {T<:AbstractFloat, RTP<:(RayTracingProblem{T, MT, AM, EA, ATM, V, M} where {MT<:MeanType, AM<:AirModel, EA<:EarthApproximation, ATM<:Yagami.RayTracing.AtmosphereSetting, V<:AbstractVector{T}, M<:AbstractMatrix{T}})}","page":"RayTracing","title":"Yagami.RayTracing.extrapolateco2ppm","text":"`extrapolateco2ppm(prob::RayTracingProblem, θ::AbstractFloat, h::AbstractFloat)`\n`extrapolateco2ppm(prob::RayTracingProblem; theta=0.0, h=0.0)`\n\nExtrapolates the CO2 concentration in ppm at a given line of angle θ and height h for a given RayTracingProblem.\n\nArguments:\n\nprob::RayTracingProblem: The ray tracing problem instance.\nθ::AbstractFloat: The angle in degree and geodesic coordinates.\nh::AbstractFloat: The altitude with respect to the surface in km.\n\nReturns:\n\nFloat64: The extrapolated CO2 concentration in ppm\n\nKey Arguments:\n\ntheta::AbstractFloat: The angle in degrees (default is 0.0).\nh::AbstractFloat: The height in kilometers (default is 0.0).\n\nExample:\n\njulia> extrapolateco2ppm(prob, 10.0, 5.0) # angle in degrees, height in km\n400.0\njulia> extrapolateco2ppm(prob; theta=10.0, h=5.0) # using keyword arguments\n400.0\njulia> extrapolateco2ppm(prob) # defaults to theta=0.0, h=0.0\n400.0\n\n\n\n\n\n","category":"method"},{"location":"RayTracing/#Yagami.RayTracing.extrapolatehumidity-Union{Tuple{RTP}, Tuple{T}, Tuple{RTP, T, T}} where {T<:AbstractFloat, RTP<:(RayTracingProblem{T, MT, AM, EA, ATM, V, M} where {MT<:MeanType, AM<:AirModel, EA<:EarthApproximation, ATM<:Yagami.RayTracing.AtmosphereSetting, V<:AbstractVector{T}, M<:AbstractMatrix{T}})}","page":"RayTracing","title":"Yagami.RayTracing.extrapolatehumidity","text":"`extrapolatehumidity(prob::RayTracingProblem, θ::AbstractFloat, h::AbstractFloat)`\n`extrapolatehumidity(prob::RayTracingProblem; theta=0.0, h=0.0)`\n\nExtrapolates the humidity at a given line of angle θ and height h for a given RayTracingProblem.\n\nArguments:\n\nprob::RayTracingProblem: The ray tracing problem instance.\nθ::AbstractFloat: The angle in degree and geodesic coordinates.\nh::AbstractFloat: The altitude with respect to the surface in km.\n\nReturns:\n\nFloat64: The extrapolated humidity in %\n\n\n\n\n\n","category":"method"},{"location":"RayTracing/#Yagami.RayTracing.extrapolatepressure-Union{Tuple{RTP}, Tuple{T}, Tuple{RTP, T, T}} where {T<:AbstractFloat, RTP<:(RayTracingProblem{T, MT, AM, EA, ATM, V, M} where {MT<:MeanType, AM<:AirModel, EA<:EarthApproximation, ATM<:Yagami.RayTracing.AtmosphereSetting, V<:AbstractVector{T}, M<:AbstractMatrix{T}})}","page":"RayTracing","title":"Yagami.RayTracing.extrapolatepressure","text":"extrapolatepressure(prob::RayTracingProblem, θ::AbstractFloat, h::AbstractFloat)     extrapolatepressure(prob::RayTracingProblem; theta=0.0, h=0.0) Extrapolates the pressure at a given line of angle θ and height h for a given RayTracingProblem.\n\nArguments:\n\nprob::RayTracingProblem: The ray tracing problem instance.\nθ::AbstractFloat: The angle in degree and geodesic coordinates.\nh::AbstractFloat: The altitude with respect to the surface in km.\n\nReturns:\n\nFloat64: The extrapolated pressure in Pa\n\nKey Arguments:\n\ntheta::AbstractFloat: The angle in degrees (default is 0.0).\nh::AbstractFloat: The height in kilometers (default is 0.0).\n\nExample:\n\njulia\n> extrapolatepressure(prob, 10.0, 5.0) # angle in degrees, height in km\n101325.0\njulia> extrapolatepressure(prob; theta=10.0, h=5.0) # using keyword arguments\n101325.0\njulia> extrapolatepressure(prob) # defaults to theta=0.0, h=0.0\n101325.0\n\n\n\n\n\n","category":"method"},{"location":"RayTracing/#Yagami.RayTracing.extrapolatetemperature-Union{Tuple{RTP}, Tuple{T}, Tuple{RTP, T, T}} where {T<:AbstractFloat, RTP<:(RayTracingProblem{T, MT, AM, EA, ATM, V, M} where {MT<:MeanType, AM<:AirModel, EA<:EarthApproximation, ATM<:Yagami.RayTracing.AtmosphereSetting, V<:AbstractVector{T}, M<:AbstractMatrix{T}})}","page":"RayTracing","title":"Yagami.RayTracing.extrapolatetemperature","text":"extrapolatetemperature(prob::RayTracingProblem, θ::AbstractFloat, h::AbstractFloat)    extrapolatetemperature(prob::RayTracingProblem; theta=0.0, h=0.0) Extrapolates the temperature at a given line of angle θ and height h for a given RayTracingProblem.\n\nArguments:\n\nprob::RayTracingProblem: The ray tracing problem instance.\nθ::AbstractFloat: The angle in degree and geodesic coordinates.\nh::AbstractFloat: The altitude with respect to the surface in km.\n\nReturns:\n\nFloat64: The extrapolated temperature in Kelvin\n\nKey Arguments:\n\ntheta::AbstractFloat: The angle in degrees (default is 0.0).\nh::AbstractFloat: The height in kilometers (default is 0.0).\n\nExample:\n\njulia> extrapolatetemperature(prob, 10.0, 5.0) # angle in degrees, height in km\n273.15\njulia> extrapolatetemperature(prob; theta=10.0, h=5.0) # using keyword arguments\n275.15\njulia> extrapolatetemperature(prob) # defaults to theta=0.0, h=0.0\n278.15\n\n\n\n\n\n","category":"method"},{"location":"RayTracing/#Yagami.RayTracing.extrapolatewavelength-Union{Tuple{RTP}, Tuple{T}, Tuple{RTP, T, T}} where {T<:AbstractFloat, RTP<:(RayTracingProblem{T, MT, AM, EA, ATM, V, M} where {MT<:MeanType, AM<:AirModel, EA<:EarthApproximation, ATM<:Yagami.RayTracing.AtmosphereSetting, V<:AbstractVector{T}, M<:AbstractMatrix{T}})}","page":"RayTracing","title":"Yagami.RayTracing.extrapolatewavelength","text":"`extrapolatewavelength(prob::RayTracingProblem, θ::AbstractFloat, h::AbstractFloat)`\n`extrapolatewavelength(prob::RayTracingProblem; theta=0.0, h=0.0)`\n\nExtrapolates the wavelength at a given line of angle θ and height h for a given RayTracingProblem.\n\nArguments:\n\nprob::RayTracingProblem: The ray tracing problem instance.\nθ::AbstractFloat: The angle in degree and geodesic coordinates.\nh::AbstractFloat: The altitude with respect to the surface in km.\n\nReturns:\n\nFloat64: The extrapolated wavelength in μm\n\nKey Arguments:\n\ntheta::AbstractFloat: The angle in degrees (default is 0.0).\nh::AbstractFloat: The height in kilometers (default is 0.0).\n\nExample:\n\njulia> extrapolatewavelength(prob, 10.0, 5.0) # angle in degrees, height in km\n1.0\njulia> extrapolatewavelength(prob; theta=10.0, h=5.0) # using keyword arguments\n1.0\njulia> extrapolatewavelength(prob) # defaults to theta=0.0, h=0.0\n1.0\n\n\n\n\n\n","category":"method"},{"location":"RayTracing/#Yagami.RayTracing.getdescending-Tuple{DistanceFunc}","page":"RayTracing","title":"Yagami.RayTracing.getdescending","text":"getdescending(df::DistanceFunc) Return the :descending field of the DistanceFunc.\n\n\n\n\n\n","category":"method"},{"location":"RayTracing/#Yagami.RayTracing.getdirectionx-Tuple{DistanceFunc}","page":"RayTracing","title":"Yagami.RayTracing.getdirectionx","text":"getdirectionx(df::DistanceFunc) Return the :directionx field of the DistanceFunc.\n\n\n\n\n\n","category":"method"},{"location":"RayTracing/#Yagami.RayTracing.getdirectiony-Tuple{DistanceFunc}","page":"RayTracing","title":"Yagami.RayTracing.getdirectiony","text":"getdirectiony(df::DistanceFunc) Return the :directiony field of the DistanceFunc.\n\n\n\n\n\n","category":"method"},{"location":"RayTracing/#Yagami.RayTracing.gethmax-Tuple{DistanceFunc}","page":"RayTracing","title":"Yagami.RayTracing.gethmax","text":"gethmax(df::DistanceFunc) Return the :hmax field of the DistanceFunc.\n\n\n\n\n\n","category":"method"},{"location":"RayTracing/#Yagami.RayTracing.gethmin-Tuple{DistanceFunc}","page":"RayTracing","title":"Yagami.RayTracing.gethmin","text":"gethmin(df::DistanceFunc) Return the :hmin field of the DistanceFunc.\n\n\n\n\n\n","category":"method"},{"location":"RayTracing/#Yagami.RayTracing.geti-Tuple{DistanceFunc}","page":"RayTracing","title":"Yagami.RayTracing.geti","text":"geti(df::DistanceFunc) Return the :i field of the DistanceFunc.\n\n\n\n\n\n","category":"method"},{"location":"RayTracing/#Yagami.RayTracing.getislevel-Tuple{DistanceFunc}","page":"RayTracing","title":"Yagami.RayTracing.getislevel","text":"getislevel(df::DistanceFunc) Return the :islevel field of the DistanceFunc.\n\n\n\n\n\n","category":"method"},{"location":"RayTracing/#Yagami.RayTracing.getj-Tuple{DistanceFunc}","page":"RayTracing","title":"Yagami.RayTracing.getj","text":"getj(df::DistanceFunc) Return the :j field of the DistanceFunc.\n\n\n\n\n\n","category":"method"},{"location":"RayTracing/#Yagami.RayTracing.getn-Tuple{DistanceFunc}","page":"RayTracing","title":"Yagami.RayTracing.getn","text":"getn(df::DistanceFunc) Return the :n field of the DistanceFunc.\n\n\n\n\n\n","category":"method"},{"location":"RayTracing/#Yagami.RayTracing.getpointx-Tuple{DistanceFunc}","page":"RayTracing","title":"Yagami.RayTracing.getpointx","text":"getpointx(df::DistanceFunc) Return the :pointx field of the DistanceFunc.\n\n\n\n\n\n","category":"method"},{"location":"RayTracing/#Yagami.RayTracing.getpointy-Tuple{DistanceFunc}","page":"RayTracing","title":"Yagami.RayTracing.getpointy","text":"getpointy(df::DistanceFunc) Return the :pointy field of the DistanceFunc.\n\n\n\n\n\n","category":"method"},{"location":"RayTracing/#Yagami.RayTracing.getquotetangent-Tuple{RayTracingProblem, Int64, Int64}","page":"RayTracing","title":"Yagami.RayTracing.getquotetangent","text":"getquotetangent(prob::RayTracingProblem, los::Int, scan::Int)   getquotetangent(prob::RayTracingProblem; los=1, scan=1) Returns the tangent point coordinates for a given line of sight (los) and scan index in a RayTracingProblem.\n\nArguments:\n\nprob::RayTracingProblem: The ray tracing problem instance.\nlos::Int: The line of sight index.\nscan::Int: The scan index.\n\nReturns:\n\nTuple{Float64, Float64}: A tuple containing the tangent height and azimuth angle at the specified los and scan.\n\nKey Arguments:\n\nlos::Int: The line of sight index (default is 1).\nscan::Int: The scan index (default is 1).\n\nExample:\n\njulia> getquotetangent(prob, 1, 1) # returns the tangent point for los=1 and scan=1\n(100.0, 45.0)\njulia> getquotetangent(prob; los=1, scan=1) # using keyword arguments\n(100.0, 45.0)\njulia> getquotetangent(prob) # defaults to los=1, scan=1\n(100.0, 45.0)\n\n\n\n\n\n","category":"method"},{"location":"RayTracing/#Yagami.RayTracing.getsatdirection-Tuple{RayTracingProblem, Int64, Int64}","page":"RayTracing","title":"Yagami.RayTracing.getsatdirection","text":"getsatdirection(prob::RayTracingProblem, los::Int, scan::Int)   getsatdirection(prob::RayTracingProblem; los=1, scan=1) Returns the satellite direction (from the nadir angle) for a given line of sight (los) and scan index in a RayTracingProblem.\n\nArguments:\n\nprob::RayTracingProblem: The ray tracing problem instance.\nlos::Int: The line of sight index.\nscan::Int: The scan index.\n\nReturns:\n\nVector{Float64}: A vector containing the x and y components of the satellite direction.\n\nKey Arguments:\n\nlos::Int: The line of sight index (default is 1).\nscan::Int: The scan index (default is 1).\n\nExample:\n\njulia julia> getsatdirection(prob, 1, 1) # returns the direction for los=1 and scan=1 [0.1, 0.2] julia> getsatdirection(prob; los=1, scan=1) # using keyword arguments [0.1, 0.2] julia> getsatdirection(prob) # defaults to los=1, scan=1 [0.1, 0.2]`\n\n\n\n\n\n","category":"method"},{"location":"RayTracing/#Yagami.RayTracing.getsatposition-Tuple{RayTracingProblem, Int64, Int64}","page":"RayTracing","title":"Yagami.RayTracing.getsatposition","text":"getsatposition(prob::RayTracingProblem, los::Int, scan::Int)   getsatposition(prob::RayTracingProblem; los=1, scan=1) Returns the satellite initial position for a given line of sight (los) and scan index in a RayTracingProblem.\n\nArguments:\n\nprob::RayTracingProblem: The ray tracing problem instance.\nlos::Int: The line of sight index.\nscan::Int: The scan index.\n\nReturns:\n\nVector{Float64}: A vector containing the x and y coordinates of the satellite position.\n\nKey Arguments:\n\nlos::Int: The line of sight index (default is 1).\nscan::Int: The scan index (default is 1).\n\nExample:\n\n```julia julia\n\ngetsatposition(prob, 1, 1) # returns the position for los=1 and scan=1\n\n[100.0, 200.0] julia> getsatposition(prob; los=1, scan=1) # using keyword arguments [100.0, 200.0] julia> getsatposition(prob) # defaults to los=1, scan=1 [100.0, 200.0]\n\n\n\n\n\n","category":"method"},{"location":"RayTracing/#Yagami.RayTracing.getθmax-Tuple{DistanceFunc}","page":"RayTracing","title":"Yagami.RayTracing.getθmax","text":"getθmax(df::DistanceFunc) Return the :θmax field of the DistanceFunc.\n\n\n\n\n\n","category":"method"},{"location":"RayTracing/#Yagami.RayTracing.getθmin-Tuple{DistanceFunc}","page":"RayTracing","title":"Yagami.RayTracing.getθmin","text":"getθmin(df::DistanceFunc) Return the :θmin field of the DistanceFunc.\n\n\n\n\n\n","category":"method"},{"location":"RayTracing/#Yagami.RayTracing.node_co2ppm-Tuple{RayTracingProblem, Int64, Int64}","page":"RayTracing","title":"Yagami.RayTracing.node_co2ppm","text":"node_co2ppm(prob::RayTracingProblem, i_theta::Int, j_h::Int) Returns the nodes of the co2ppm for a given RayTracingProblem at specified wedge edge.\n\nArguments:\n\nprob::RayTracingProblem: The ray tracing problem instance.\ni_theta::Int: The index of the theta knot (angle).\nj_h::Int: The index of the h knot (height).\n\nReturns:\n\nTuple{Int,Int},T: A tuple containing the theta and h values at the specified indices and the value of co2ppm.\n\nExample:\n\njulia> node_co2ppm(prob, 1, 1) # returns the nodes for i_theta=1 and j_h=1\n(0.0, 0.0, 273.15)\n\n\n\n\n\n","category":"method"},{"location":"RayTracing/#Yagami.RayTracing.node_humidity-Tuple{RayTracingProblem, Int64, Int64}","page":"RayTracing","title":"Yagami.RayTracing.node_humidity","text":"node_humidity(prob::RayTracingProblem, i_theta::Int, j_h::Int) Returns the nodes of the humidity for a given RayTracingProblem at specified wedge edge.\n\nArguments:\n\nprob::RayTracingProblem: The ray tracing problem instance.\ni_theta::Int: The index of the theta knot (angle).\nj_h::Int: The index of the h knot (height).\n\nReturns:\n\nTuple{Int,Int},T: A tuple containing the theta and h values at the specified indices and the value of humidity.\n\nExample:\n\njulia> node_humidity(prob, 1, 1) # returns the nodes for i_theta=1 and j_h=1\n(0.0, 0.0, 273.15)\n\n\n\n\n\n","category":"method"},{"location":"RayTracing/#Yagami.RayTracing.node_pressure-Tuple{RayTracingProblem, Int64, Int64}","page":"RayTracing","title":"Yagami.RayTracing.node_pressure","text":"node_pressure(prob::RayTracingProblem, i_theta::Int, j_h::Int) Returns the nodes of the pressure for a given RayTracingProblem at specified wedge edge.\n\nArguments:\n\nprob::RayTracingProblem: The ray tracing problem instance.\ni_theta::Int: The index of the theta knot (angle).\nj_h::Int: The index of the h knot (height).\n\nReturns:\n\nTuple{Int,Int},T: A tuple containing the theta and h values at the specified indices and the value of pressure.\n\nExample:\n\njulia> node_pressure(prob, 1, 1) # returns the nodes for i_theta=1 and j_h=1\n(0.0, 0.0, 273.15)\n\n\n\n\n\n","category":"method"},{"location":"RayTracing/#Yagami.RayTracing.node_temperature-Tuple{RayTracingProblem, Int64, Int64}","page":"RayTracing","title":"Yagami.RayTracing.node_temperature","text":"node_temperature(prob::RayTracingProblem, i_theta::Int, j_h::Int) Returns the nodes of the temperature for a given RayTracingProblem at specified wedge edge.\n\nArguments:\n\nprob::RayTracingProblem: The ray tracing problem instance.\ni_theta::Int: The index of the theta knot (angle).\nj_h::Int: The index of the h knot (height).\n\nReturns:\n\nTuple{Int,Int},T: A tuple containing the theta and h values at the specified indices and the value of temperature.\n\nExample:\n\njulia> node_temperature(prob, 1, 1) # returns the nodes for i_theta=1 and j_h=1\n(0.0, 0.0, 273.15)\n\n\n\n\n\n","category":"method"},{"location":"RayTracing/#Yagami.RayTracing.node_wavelength-Tuple{RayTracingProblem, Int64, Int64}","page":"RayTracing","title":"Yagami.RayTracing.node_wavelength","text":"node_wavelength(prob::RayTracingProblem, i_theta::Int, j_h::Int) Returns the nodes of the wavelength for a given RayTracingProblem at specified wedge edge.\n\nArguments:\n\nprob::RayTracingProblem: The ray tracing problem instance.\ni_theta::Int: The index of the theta knot (angle).\nj_h::Int: The index of the h knot (height).\n\nReturns:\n\nTuple{Int,Int},T: A tuple containing the theta and h values at the specified indices and the value of wavelength.\n\nExample:\n\njulia> node_wavelength(prob, 1, 1) # returns the nodes for i_theta=1 and j_h=1\n(0.0, 0.0, 273.15)\n\n\n\n\n\n","category":"method"},{"location":"RayTracing/#Yagami.RayTracing.num_edges-Tuple{RayTracingProblem}","page":"RayTracing","title":"Yagami.RayTracing.num_edges","text":"num_edges(prob::RayTracingProblem) Returns the number of edges in a RayTracingProblem as N x M, where N is the number of angle knots and M is the number of height knots.\n\nArguments:\n\nprob::RayTracingProblem: The ray tracing problem instance.\n\nReturns:\n\nTuple{Int, Int}: A tuple containing the number of edges (N, M).\n\nNote:\n\nDue to the circularity of the matrix along the theta dimension, the number of edges in the theta direction is one less than the number of knots in the theta direction, while the number of edges in the height dimension is one less than the number of knots in the height direction.\n\nExample:\n\njulia> num_edges(prob) # returns the number of edges in the problem\n(10, 19)\n\nSee also: num_wedges\n\n\n\n\n\n","category":"method"},{"location":"RayTracing/#Yagami.RayTracing.num_wedges-Tuple{RayTracingProblem}","page":"RayTracing","title":"Yagami.RayTracing.num_wedges","text":"numwedges(prob::RayTracingProblem) Returns the number of wedges in a RayTracingProblem as N x M, where N is the number of angle knots and M is the number of height knots.\n\nArguments:\n\nprob::RayTracingProblem: The ray tracing problem instance.\n\nReturns:\n\nTuple{Int, Int}: A tuple containing the number of wedges (N, M).\n\nNote:\n\ndue to the circularity of the matrix along the theta dimension, the number of wedges in the theta dimension is the same as the number of edges in the theta direction, while the number of wedges in the height dimension is one less than the number of edges in the h direction.\n\nExample:\n\njulia> numwedges(prob) # returns the number of wedges in the problem\n(10, 20)\n\nSee also: num_edges\n\n\n\n\n\n","category":"method"},{"location":"RayTracing/#Yagami.RayTracing.raytracing!-Union{Tuple{RR}, Tuple{RP}, Tuple{RE}, Tuple{T}, Tuple{RR, RP}, Tuple{RR, RP, Int64}, Tuple{RR, RP, Int64, T}} where {T<:AbstractFloat, RE<:AbstractResult{T}, RP<:(RayTracingProblem{T, MT, AM, EA, ATM, V, M} where {MT<:MeanType, AM<:AirModel, EA<:EarthApproximation, ATM<:Yagami.RayTracing.AtmosphereSetting, V<:AbstractVector{T}, M<:AbstractMatrix{T}}), RR<:AbstractMatrix{RE}}","page":"RayTracing","title":"Yagami.RayTracing.raytracing!","text":"raytracing!(results, problem)\nraytracing!(results, problem, itermax)\nraytracing!(results, problem, itermax, tol)\n\n\nPerform ray tracing calculations for a given problem and store the results in the provided results matrix. This function iterates over the points and directions specified in the problem, solving for the ray path using the Zbrent method. It updates the results matrix with the ray tracing results for each point and direction. It also writes a log of the ray tracing results to the logger associated with the problem.\n\nArguments:\n\nresults::RR: The results matrix where the ray tracing results will be stored.\nproblem::RP: The ray tracing problem containing the points, directions, refractive index grid, and other necessary data.\nitermax::Int: The maximum number of iterations to perform for each ray tracing calculation (default is 100).\ntol::T: The tolerance for the ray tracing calculations (default is 1e-10).\n\n\n\n\n\n","category":"method"},{"location":"RayTracing/#Yagami.RayTracing.raytracing_grid!","page":"RayTracing","title":"Yagami.RayTracing.raytracing_grid!","text":"`raytracing_grid!(ax, angles, altitudes;majoraxis = WGS84MAJORAXIS, minoraxis = WGS84MINORAXIS,color=:black,linewidth=3,kwargs...)`\n\nDraws a grid of rays on an axis, where each ray is defined by a constant angle and altitude. The rays are drawn as vertical lines at constant angles and horizontal lines at constant altitudes. The grid is based on an ellipsoid defined by the major and minor axes.\n\n\n\n\n\n","category":"function"},{"location":"RayTracing/#Yagami.RayTracing.raytracing_parallel!-Union{Tuple{RR}, Tuple{RP}, Tuple{RE}, Tuple{T}, Tuple{RR, RP}, Tuple{RR, RP, Int64}, Tuple{RR, RP, Int64, T}} where {T<:AbstractFloat, RE<:AbstractResult{T}, RP<:(RayTracingProblem{T, MT, AM, EA, ATM, V, M} where {MT<:MeanType, AM<:AirModel, EA<:EarthApproximation, ATM<:Yagami.RayTracing.AtmosphereSetting, V<:AbstractVector{T}, M<:AbstractMatrix{T}}), RR<:AbstractMatrix{RE}}","page":"RayTracing","title":"Yagami.RayTracing.raytracing_parallel!","text":"raytracing_parallel!(results, problem)\nraytracing_parallel!(results, problem, itermax)\nraytracing_parallel!(results, problem, itermax, tol)\n\n\nPerform parallel ray tracing calculations for a given problem and store the results in the provided results matrix. This function uses multithreading to perform ray tracing calculations for each point and direction specified in the problem. It updates the results matrix with the ray tracing results for each point and direction. It also writes a log of the ray tracing results to the logger associated with the problem.\n\nArguments:\n\nresults::RR: The results matrix where the ray tracing results will be stored.\nproblem::RP: The ray tracing problem containing the points, directions, refractive index grid, and other necessary data.\nitermax::Int: The maximum number of iterations to perform for each ray tracing calculation (default is 100).\ntol::T: The tolerance for the ray tracing calculations (default is 1e-10).\n\n\n\n\n\n","category":"method"},{"location":"RayTracing/#Yagami.RayTracing.raytracingθ!-Union{Tuple{RR}, Tuple{RP}, Tuple{RE}, Tuple{T}, Tuple{RR, RP}, Tuple{RR, RP, Int64}, Tuple{RR, RP, Int64, T}} where {T<:AbstractFloat, RE<:AbstractResult{T}, RP<:(RayTracingProblem{T, MT, AM, EA, ATM, V, M} where {MT<:MeanType, AM<:AirModel, EA<:EarthApproximation, ATM<:Yagami.RayTracing.AtmosphereSetting, V<:AbstractVector{T}, M<:AbstractMatrix{T}}), RR<:AbstractMatrix{RE}}","page":"RayTracing","title":"Yagami.RayTracing.raytracingθ!","text":"raytracingθ!(results, problem)\nraytracingθ!(results, problem, itermax)\nraytracingθ!(results, problem, itermax, tol)\n\n\nPerform ray tracing calculations for a given problem and store the results in the provided results matrix. This function iterates over the points and directions specified in the problem, solving for the ray path using the Zbrent method. It updates the results matrix with the ray tracing results for each point and direction. It also writes a log of the ray tracing results to the logger associated with the problem.\n\nArguments:\n\nresults::RR: The results matrix where the ray tracing results will be stored.\nproblem::RP: The ray tracing problem containing the points, directions, refractive index grid, and other necessary data.\nitermax::Int: The maximum number of iterations to perform for each ray tracing calculation (default is 100).\ntol::T: The tolerance for the ray tracing calculations (default is 1e-10).\n\n\n\n\n\n","category":"method"},{"location":"RayTracing/#Yagami.RayTracing.raytracingθ_parallel!-Union{Tuple{RR}, Tuple{RP}, Tuple{RE}, Tuple{T}, Tuple{RR, RP}, Tuple{RR, RP, Int64}, Tuple{RR, RP, Int64, T}} where {T<:AbstractFloat, RE<:AbstractResult{T}, RP<:(RayTracingProblem{T, MT, AM, EA, ATM, V, M} where {MT<:MeanType, AM<:AirModel, EA<:EarthApproximation, ATM<:Yagami.RayTracing.AtmosphereSetting, V<:AbstractVector{T}, M<:AbstractMatrix{T}}), RR<:AbstractMatrix{RE}}","page":"RayTracing","title":"Yagami.RayTracing.raytracingθ_parallel!","text":"raytracingθ_parallel!(results, problem)\nraytracingθ_parallel!(results, problem, itermax)\nraytracingθ_parallel!(results, problem, itermax, tol)\n\n\nPerform parallel ray tracing calculations for a given problem and store the results in the provided results matrix. This function uses multithreading to perform ray tracing calculations for each point and direction specified in the problem. It updates the results matrix with the ray tracing results for each point and direction. It also writes a log of the ray tracing results to the logger associated with the problem.\n\nArguments:\n\nresults::RR: The results matrix where the ray tracing results will be stored.\nproblem::RP: The ray tracing problem containing the points, directions, refractive index grid, and other necessary data.\nitermax::Int: The maximum number of iterations to perform for each ray tracing calculation (default is 100).\ntol::T: The tolerance for the ray tracing calculations (default is 1e-10).\n\n\n\n\n\n","category":"method"},{"location":"RayTracing/#Yagami.RayTracing.wedge_refractive-Tuple{RayTracingProblem, Int64, Int64}","page":"RayTracing","title":"Yagami.RayTracing.wedge_refractive","text":"wedge_refractive(problem::RayTracingProblem, i_theta::Int, j_h::Int;complement::Bool=false) Returns the refractive index at a given wedge edge specified by indices i_theta and j_h in a RayTracingProblem.\n\nArguments:\n\nproblem::RayTracingProblem: The ray tracing problem instance.\ni_theta::Int: The index of the theta knot (angle).\nj_h::Int: The index of the h knot (height).\n\nKey Arguments:\n\ncomplement::Bool: If true, returns the complement of the refractive index (n-1), that can be more useful in some cases (default is false).\n\nReturns:\n\nTuple{Tuple{Float64, Float64}, Float64}: A tuple containing the theta and h values at the specified indices and the refractive index.\n\nExample:\n\njulia> wedge_refractive(prob, 1, 1) # returns the refractive index for i_theta=1 and j_h=1\n((0.0, 0.0), 1.0003)\n\n\n\n\n\n","category":"method"},{"location":"CurtisGodson/#Yagami.CurtisGodson.QuadraturePoints","page":"CurtisGodson","title":"Yagami.CurtisGodson.QuadraturePoints","text":"A structure to hold quadrature points and weights for numerical integration. Where N is the number of quadrature points and T is the type of the points and weights.\n\n\n\n\n\n","category":"type"},{"location":"CurtisGodson/#Yagami.CurtisGodson.get_quadrature_points-Union{Tuple{T}, Tuple{Type{T}, Int64}} where T<:AbstractFloat","page":"CurtisGodson","title":"Yagami.CurtisGodson.get_quadrature_points","text":"get_quadrature_points(_, n)\n\n\nGet quadrature points and weights for numerical integration using Gauss-Legendre quadrature.   The function returns a QuadraturePoints object containing the points and weights.\n\nArguments\n\nT: Type of the quadrature points (default is Float64).\nn: Number of quadrature points (must be positive).\n\nReturns\n\nA QuadraturePoints object with the quadrature points and weights.\n\n\n\n\n\n","category":"method"},{"location":"CurtisGodson/#Yagami.CurtisGodson.linintegral!-Union{Tuple{F}, Tuple{N}, Tuple{T}, Tuple{AbstractArray{T}, F, QuadraturePoints{N, T}, AbstractArray{T}, AbstractArray}} where {T<:AbstractFloat, N, F}","page":"CurtisGodson","title":"Yagami.CurtisGodson.linintegral!","text":"linintegral!(out, f, Q, t, p)\n\n\nCompute the linear integral of a function f over the quadrature points Q scaled by a factor t. It is assumed that the integral starts at 0 and ends at t. The function uses the quadrature points and weights to evaluate the integral numerically. The function evaluates f at the quadrature points scaled by t, computes the dot product with the weights, and stores the result in the output array out. The function f needs to have the following signature:\n\nf(points::AbstractVector{T}, p) where {T<:AbstractFloat}\n\nwhere p is an optional parameter that can be passed to the function to account for additional parameters in the integral.\n\nArguments\n\nout: An output array to store the results of the integral.\nf: A function that takes a vector of points and an optional parameter p.\nQ: A QuadraturePoints object containing the quadrature points and weights.\nt: the end of the integral path, which is a vector of the same size as out.\np: An optional parameter passed to the function f. Can be a vector of the same size of out or a single value.\n\nReturns\n\nThe output array with the computed linear integrals.\n\n\n\n\n\n","category":"method"},{"location":"CurtisGodson/#Yagami.CurtisGodson.linintegral-Union{Tuple{N}, Tuple{T}, Tuple{F}, Tuple{F, QuadraturePoints{N, T}}, Tuple{F, QuadraturePoints{N, T}, T}, Tuple{F, QuadraturePoints{N, T}, T, Any}} where {F, T<:AbstractFloat, N}","page":"CurtisGodson","title":"Yagami.CurtisGodson.linintegral","text":"linintegral(f, Q)\nlinintegral(f, Q, t)\nlinintegral(f, Q, t, p)\n\n\nCompute the linear integral of a function f over the quadrature points Q scaled by a factor t. It is assumed that the integral starts at 0 and ends at t. The function uses the quadrature points and weights to evaluate the integral numerically. The function evaluates f at the quadrature points scaled by t, computes the dot product with the weights, and returns the result multiplied by t/2.\n\nThe function f needs to have the following signature:\n\nf(points::AbstractVector{T}, p) where {T<:AbstractFloat}\n\nwhere p is an optional parameter that can be passed to the function to account for additional parameters in the integral.\n\nArguments\n\nf: A function that takes a vector of points and an optional parameter p.\nQ: A QuadraturePoints object containing the quadrature points and weights.\nt: the end of the integral path, which is a scalar value.\np: An optional parameter passed to the function f.\n\nReturns\n\nThe computed linear integral as a scalar value.\n\n\n\n\n\n","category":"method"},{"location":"#Yagami","page":"Home","title":"Yagami","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for Yagami.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Package for ray tracing and retrieval for the CAIRT project.","category":"page"},{"location":"#Structure","page":"Home","title":"Structure","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package is structured as follow:\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"flowchart TD\n\nsubgraph Yagami[\"📂 Yagami Package\"]\n  \n  subgraph YagamiCore[\"📦 Yagami Core\"]\n    CoreDescription[\"Common functions,<br/>constants, and utilities<br/>shared across modules\"]\n  end\n\n  subgraph Modules\n    direction LR\n    MaterialProperties[\"📚 Material Properties<br/>(Refractive indices,<br/>atmosphere discretization)\"]\n    RayTracing[\"🔭 RayTracing<br/>(Finding intersections<br/>with Earth)\"]\n    CurtisGodson[\"📐 CurtisGodson<br/>(Integral computations<br/>for direct model)\"]\n  end\n\n  YagamiCore --> MaterialProperties\n  YagamiCore --> RayTracing\n  YagamiCore --> CurtisGodson\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"Python scripts for the testing the material properties are adapted from the Refractive Index Database created by Mikhail Polyanskiy.[1]","category":"page"},{"location":"#References","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"[1]: Polyanskiy, Mikhail N. \"Refractiveindex. info database of optical constants.\" Scientific Data 11.1 (2024): 94.","category":"page"}]
}
